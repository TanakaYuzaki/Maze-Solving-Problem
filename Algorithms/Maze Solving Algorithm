import matplotlib.pyplot as plt
import numpy as np
import random
from queue import Queue

class Maze:
    def __init__(self):
        self.M = None
        self.Dim = None
        self.path = [(0,0)]
    
    def Generate_Maze(self,dim):
        maze = np.ones((dim*2+1,dim*2+1))
        r,c = 0,0
        maze[r*2+1,c*2+1] = 0
        stack = [(r,c)]
        while stack:
            c_r,c_c = stack[-1]
            directions = [(0,1),(0,-1),(1,0),(-1,0)]
            random.shuffle(directions)
            for i,j in directions:
                n_r = c_r + i
                n_c = c_c + j
                if n_r >= 0 and n_c >= 0 and n_r < dim and n_c < dim and maze[2*n_r+1][2*n_c+1] == 1:
                    maze[2*n_r+1][2*n_c+1] = 0
                    maze[c_r*2+1+i,c_c*2+1+j] = 0
                    stack.append((n_r,n_c))
                    break
            else:
                stack.pop()
        maze[1][0] = 0
        maze[-2][-1] = 0
        self.M = maze
        self.Dim = dim
    
    def DFS(self):
        s_r,s_e = 0,0
        stacks = [(s_r,s_e)]
        visited = set()
        while stacks:
            cr, cc = stacks[-1]
            visited.add((cr,cc))
            directions = [(1,0),(-1,0),(0,1),(0,-1)]
            random.shuffle(directions)
            for dr,dc in directions:
                nr = dr + cr
                nc = dc + cc
                if cc == self.Dim-1 and self.M[2*cr+1][2*cc+1+1] == 0:
                    return self.path
                if nr >= 0 and nc >= 0 and nr < self.Dim and (nr,nc) not in visited and nc < self.Dim and self.M[2*cr+1+dr][2*cc+1+dc] == 0:
                    stacks.append((nr,nc))
                    self.path.append((nr,nc))
                    break
            else:
                stacks.pop()
                self.path.pop()
        return False
                    
                
        
    
                
    
                
            
Test = Maze()
Test.Generate_Maze(100)
print(Test.M)
print(Test.DFS())
