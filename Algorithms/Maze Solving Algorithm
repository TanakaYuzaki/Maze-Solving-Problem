import matplotlib.pyplot as plt
import numpy as np
import random
from collections import deque
import matplotlib.pyplot as plt
import matplotlib.animation as animation

class Maze:
    def __init__(self):
        self.M = None
        self.Dim = None
        self.path = None
    
    def Generate_Maze(self,dim):
        maze = np.ones((dim*2+1,dim*2+1))
        r,c = 0,0
        maze[r*2+1,c*2+1] = 0
        stack = [(r,c)]
        while stack:
            c_r,c_c = stack[-1]
            directions = [(0,1),(0,-1),(1,0),(-1,0)]
            random.shuffle(directions)
            for i,j in directions:
                n_r = c_r + i
                n_c = c_c + j
                if n_r >= 0 and n_c >= 0 and n_r < dim and n_c < dim and maze[2*n_r+1][2*n_c+1] == 1:
                    maze[2*n_r+1][2*n_c+1] = 0
                    maze[c_r*2+1+i,c_c*2+1+j] = 0
                    stack.append((n_r,n_c))
                    break
            else:
                stack.pop()
        maze[1][0] = 0
        maze[-2][-1] = 0
        self.M = maze
        self.Dim = dim
    
    def Solve(self):
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        start = (1,1)
        end = (self.M.shape[0]-1,self.M.shape[1]-1)
        visited = np.zeros_like(self.M,dtype = bool)
        visited[(1,1)] = True
        queue = deque()
        queue.append((start,[]))
        while queue:
            node,path = queue.pop()
            for dr,dc in directions:
                next_node = (node[0] + dr,node[1] + dc)
                if next_node == end:
                    self.path = path
                    return path
                
                if (next_node[0] >= 0 and next_node[1] >= 0 and next_node[0] < self.M.shape[0] and next_node[1] < self.M.shape[1] and self.M[next_node] == 0 and not visited[next_node]):
                    visited[next_node] = True
                    queue.append((next_node,path+[node]))
        
                    
        
        
        
    
Test = Maze()
Test.Generate_Maze(20)
print(Test.M)
print(Test.Solve())
